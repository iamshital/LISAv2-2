# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License.

function Main {
	# Create test result
	$currentTestResult = CreateTestResultObject
	$resultArr = @()

	try {
		$noClient = $true
		$noServer = $true
		foreach ($vmData in $allVMData) {
			if ($vmData.RoleName -imatch "client") {
				$clientVMData = $vmData
				$noClient = $false
			} elseif ($vmData.RoleName -imatch "server") {
				$noServer = $false
				$serverVMData = $vmData
			}
		}
		if ($noClient) {
			throw "No client VM defined. Be sure that, Client VM role name matches with the pattern *client*. Aborting Test."
		}
		if ($noServer) {
			throw "No server VM defined. Be sure that, Server machine role names matches with pattern *server* Aborting Test."
		}

		LogMsg "CLIENT VM details :"
		LogMsg "  RoleName : $($clientVMData.RoleName)"
		LogMsg "  Public IP : $($clientVMData.PublicIP)"
		LogMsg "  SSH Port : $($clientVMData.SSHPort)"
		LogMsg "  Internal IP : $($clientVMData.InternalIP)"
		LogMsg "SERVER VM details :"
		LogMsg "  RoleName : $($serverVMData.RoleName)"
		LogMsg "  Public IP : $($serverVMData.PublicIP)"
		LogMsg "  SSH Port : $($serverVMData.SSHPort)"
		LogMsg "  Internal IP : $($serverVMData.InternalIP)"

		# enables root access and key auth
		ProvisionVMsForLisa -allVMData $allVMData -installPackagesOnRoleNames "none"

		LogMsg "Generating constansts.sh ..."
		$constantsFile = "$LogDir\constants.sh"

		# separate user provided files source ps1s now
		# add sh to constants.sh to be sourced on VM
		$bashFilePaths = ""
		$bashFileNames = ""
		foreach ($filePath in $currentTestData.files.Split(",")) {
			$fileExt = $filePath.Split(".")[$filePath.Split(".").count - 1]

			if ($fileExt -eq "sh") {
				$bashFilePaths = "$bashFilePaths$filePath,"
				$fileName = $filePath.Split("\")[$filePath.Split("\").count - 1]
				$bashFileNames = "$bashFileNames$fileName "
			} elseif ($fileExt -eq "ps1") {
				# source user provided file for `prepareParameters`
				#   and `verifyPerf` calls
				. $filePath
			} else {
				throw "user provided unsupported file type"
			}
		}
		# remove respective trailing delimiter
		$bashFilePaths = $bashFilePaths -replace ".$"
		$bashFileNames = $bashFileNames -replace ".$"

		Set-Content -Value "# Generated by Azure Automation." -Path $constantsFile
		# let user do extra paramter processing, not sure this necessary anymore
		# just always pass all parameters, then do processing VM side
		# is there a case when this context is necessary
		Prepare-Parameters

		Add-Content -Value "SERVER=$($serverVMData.InternalIP)" -Path $constantsFile
		Add-Content -Value "CLIENT=$($clientVMData.InternalIP)" -Path $constantsFile
		Add-Content -Value "USER_FILES='$bashFileNames'" -Path $constantsFile

		LogMsg "constanst.sh created successfully..."
		LogMsg (Get-Content -Path $constantsFile)

		# start test
		$myString = @"
cd /root/
./dpdkSetupAndRunTest.sh 2>&1 > dpdkConsoleLogs.txt
"@
		Set-Content "$LogDir\start.sh" $myString
		RemoteCopy -uploadTo $clientVMData.PublicIP -port $clientVMData.SSHPort -files ".\$constantsFile,.\Testscripts\Linux\utils.sh,.\Testscripts\Linux\dpdkUtils.sh,.\Testscripts\Linux\dpdkSetupAndRunTest.sh,.\$LogDir\start.sh" -username "root" -password $password -upload
		# upload user specified file from Testcase.xml to root's home
		RemoteCopy -uploadTo $clientVMData.PublicIP -port $clientVMData.SSHPort -files $bashFilePaths -username "root" -password $password -upload

		RunLinuxCmd -ip $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -command "chmod +x *.sh"
		$testJob = RunLinuxCmd -ip $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -command "./start.sh" -RunInBackground

		# monitor test
		while ((Get-Job -Id $testJob).State -eq "Running") {
			$currentStatus = RunLinuxCmd -ip $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -command "tail -2 dpdkConsoleLogs.txt | head -1"
			LogMsg "Current Test Status : $currentStatus"
			WaitFor -seconds 20
		}
		$finalStatus = RunLinuxCmd -ip $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -command "cat /root/state.txt"
		RemoteCopy -downloadFrom $clientVMData.PublicIP -port $clientVMData.SSHPort -username "root" -password $password -download -downloadTo $LogDir -files "*.csv, *.txt, *.log, *.tar.gz"

		if ($finalStatus -imatch "TestFailed") {
			LogErr "Test failed. Last known status : $currentStatus."
			$testResult = "FAIL"
		}
		elseif ($finalStatus -imatch "TestAborted") {
			LogErr "Test Aborted. Last known status : $currentStatus."
			$testResult = "ABORTED"
		}
		elseif ($finalStatus -imatch "TestCompleted") {
			LogMsg "Test Completed."
			$testResult = (Verify-Performance)
		}
		elseif ($finalStatus -imatch "TestRunning") {
			LogWarn "Powershell backgroud job for test is completed but VM is reporting that test is still running. Please check $LogDir\zkConsoleLogs.txt"
			LogWarn "Contests of summary.log : $testSummary"
			$testResult = "ABORTED"
		}

		LogMsg "Test result : $testResult"
	}
	catch {
		$ErrorMessage =  $_.Exception.Message
		$ErrorLine = $_.InvocationInfo.ScriptLineNumber
		LogErr "EXCEPTION : $ErrorMessage at line: $ErrorLine"
	} finally {
		if (!$testResult) {
			$testResult = "Aborted"
		}
		$resultArr += $testResult
		$currentTestResult.TestSummary +=  CreateResultSummary -testResult $testResult -metaData "DPDK-TESTPMD" -checkValues "PASS,FAIL,ABORTED" -testName $currentTestData.testName
	}

	$currentTestResult.TestResult = GetFinalResultHeader -resultarr $resultArr
	return $currentTestResult.TestResult
}

Main